0. `Win32 API` acronyms demystification:

- [Handles and Data Types](https://en.wikibooks.org/wiki/Windows_Programming/Handles_and_Data_Types):

  - On 16-bit architectures (16-bit Windows) there are 2 types of pointers, P for `pointer` and `LP` stands for `long pointer`.
  - `Long pointers` (also called far pointers) were needed to address memory ranges outside of the current segment.
  - The `LP prefix` has been preserved to make it easier to port 16-bit code to 32-bit Windows.
  - Today there is no distinction, and `these pointer types are all equivalent`. `Avoid using these prefixes; or if you must use one, then use P`.

    ```c
    RECT   *rect;  // Pointer to a RECT structure.
    LPRECT  rect;  // The same
    PRECT   rect;  // Also the same.
    ```

    - Pointer precision type: `[DWORD_PTR, INT_PTR, LONG_PTR, ULONG_PTR, UINT_PTR]`.

  - Integer types: `#include <stdint.h>`

    ```c
    typedef uint8_t BYTE;
    typedef uint16_t WORD;
    typedef uint32_t DWORD;
    typedef uint64_t QWORD;

    typedef long LONG;
    typedef unsigned long ULONG;
    typedef int INT;
    typedef unsigned int UINT;
    typedef short SHORT;
    typedef unsigned short USHORT;
    typedef char CHAR;
    typedef unsigned char UCHAR;
    ```

    | Data type | Size    | Signed?  |
    | --------- | ------- | -------- |
    | BYTE      | 8 bits  | Unsigned |
    | DWORD     | 32 bits | Unsigned |
    | INT32     | 32 bits | Signed   |
    | INT64     | 64 bits | Signed   |
    | LONG      | 32 bits | Signed   |
    | LONGLONG  | 64 bits | Signed   |
    | UINT32    | 32 bits | Unsigned |
    | UINT64    | 64 bits | Unsigned |
    | ULONG     | 32 bits | Unsigned |
    | ULONGLONG | 64 bits | Unsigned |
    | WORD      | 16 bits | Unsigned |

- [Working with Strings](https://learn.microsoft.com/en-us/windows/win32/learnwin32/working-with-strings):

  | `Typedef`             | Definition        |
  | --------------------- | ----------------- |
  | `CHAR`                | `char`            |
  | `PSTR` or `LPSTR`     | `char *`          |
  | `PCSTR` or `LPCSTR`   | `const char *`    |
  | `PWSTR` or `LPWSTR`   | `wchar_t *`       |
  | `PCWSTR` or `LPCWSTR` | `const wchar_t *` |

  | Macro                    | Unicode   | ANSI   |
  | ------------------------ | --------- | ------ |
  | `TCHAR`                  | `wchar_t` | `char` |
  | `TEXT("x")` or `_T("x")` | `L"x"`    | `"x"`  |

  ```c
  typedef wchar_t WCHAR;

  // To declare a wide-character literal or a wide-character string literal, put L before the literal.
  wchar_t a = L'a';
  wchar_t *str = L"hello";

  #ifdef UNICODE
  #define TCHAR WORD
  #define SetWindowText SetWindowTextW
  #else
  #define TCHAR BYTE
  #define SetWindowText SetWindowTextA
  #endif
  ```

- In Win32 API functions, `W`, `Ex`, and `A` are suffixes that indicate the character set and other variations in the function names. Specifically:

  - `W` stands for `Wide`, which indicates that the function uses Unicode character encoding. For example, the function `MessageBoxW` displays a message box with Unicode text.

  - `Ex` stands for `Extended`, which indicates that the function has an extended version with additional parameters. For example, the function `CreateWindowExW` creates a window with extended style options and uses Unicode character encoding.

  - `A` stands for `Ansi`, which indicates that the function uses the legacy ANSI character encoding. For example, the function `MessageBoxA` displays a message box with ANSI text.

- In general, it's recommended to use the `W` versions of the functions whenever possible, as they support a wider range of characters and are more compatible with internationalization and localization. However, the `A` versions may still be necessary for compatibility with older software or certain system configurations.
